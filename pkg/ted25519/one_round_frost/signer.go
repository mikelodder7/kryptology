package one_round_frost

import (
	crand "crypto/rand"
	"fmt"

	"github.com/coinbase/kryptology/internal"
	"github.com/coinbase/kryptology/pkg/core/curves"
	dkg "github.com/coinbase/kryptology/pkg/dkg/frost"
	"github.com/coinbase/kryptology/pkg/sharing"
	"github.com/coinbase/kryptology/pkg/ted25519/frost"
)

// Signer is a tSchnorr player performing the signing operation.
type Signer struct {
	skShare          curves.Scalar // secret signing share for this signer
	vkShare          curves.Point  // store verification key share
	verificationKey  curves.Point  // verification key
	id               uint32        // The ID assigned to this signer's shamir share
	threshold        uint32
	limit            uint32
	curve            *curves.Curve
	lCoeffs          map[uint32]curves.Scalar // lCoeffs are Lagrange coefficients of each cosigner.
	cosigners        []uint32
	challengeDeriver frost.ChallengeDeriver

	// Nonce stored after Commit
	// SmallDs, SmallEs are secret scalars this signer generates and stored in Commit
	// Exporting them because external usage of it will need to access these, encrypt nonce and store them somewhere.
	smallDs, smallEs []curves.Scalar

	// Values stored after Sign
	msg    []byte
	c      curves.Scalar
	capRis map[uint32]curves.Point
	capR   curves.Point
}

// SigningCommitment includes a commitment pair (Di, Ei) generated in Commit method by a signer.
type SigningCommitment struct {
	capDi, capEi curves.Point
}

// SignatureShare includes a signature share generated by a signer after running Sign method.
type SignatureShare struct {
	zi curves.Scalar
}

// Signature includes Schnorr signature elements.
type Signature struct {
	capR curves.Point
	z    curves.Scalar
}

// NewSigner creates a signer from a dkg participant
// Note that we can pre-assign Lagrange coefficients of each cosigner. This optimizes performance.
// See paragraph 3 of section 3 in the draft - https://tools.ietf.org/pdf/draft-komlo-frost-00.pdf
func NewSigner(dkgOutput *dkg.DkgParticipant, cosigners []uint32, challengeDeriver frost.ChallengeDeriver) (*Signer, error) {
	if dkgOutput == nil || len(cosigners) == 0 {
		return nil, internal.ErrNilArguments
	}

	if dkgOutput.Threshold > uint32(len(cosigners)) {
		return nil, fmt.Errorf("threshold is higher than number of signers")
	}

	// Prepare Lagrange coefficients
	scheme, err := sharing.NewShamir(dkgOutput.Threshold, dkgOutput.Limit, dkgOutput.Curve)
	if err != nil {
		return nil, fmt.Errorf("unable to initialte shamir scheme")
	}
	lCoeffs, err := scheme.LagrangeCoeffs(cosigners)
	if err != nil {
		return nil, fmt.Errorf("unable to compute Lagrange coefficients")
	}

	return &Signer{
		skShare:          dkgOutput.SkShare,
		vkShare:          dkgOutput.VkShare,
		verificationKey:  dkgOutput.VerificationKey,
		id:               dkgOutput.Id,
		threshold:        dkgOutput.Threshold,
		limit:            dkgOutput.Limit,
		curve:            dkgOutput.Curve,
		lCoeffs:          lCoeffs,
		cosigners:        cosigners,
		challengeDeriver: challengeDeriver,
	}, nil
}

// Commit is used in the one-time preprocessing phase, in which each signer commits to a number of nonce and output commitments.
// These commitments will be sent to the coordinator.
func (signer *Signer) CommitInPreprocessingPhase(signatureCountBound uint32) ([]*SigningCommitment, error) {
	// Make sure signer is not empty
	if signer == nil || signer.curve == nil {
		return nil, internal.ErrNilArguments
	}

	// Make sure bound is valid.
	// Note that we don't need to check cases bound < 0 since bound is of uint32 type
	if signatureCountBound == 0 {
		return nil, fmt.Errorf("invalid bound number")
	}

	dis := []curves.Scalar{}
	eis := []curves.Scalar{}
	signingCommitments := []*SigningCommitment{}

	for i := uint32(1); i <= signatureCountBound; i++ {
		// Step 1 - Sample di, ei
		di := signer.curve.Scalar.Random(crand.Reader)
		dis = append(dis, di)

		ei := signer.curve.Scalar.Random(crand.Reader)
		eis = append(eis, ei)

		// Step 2 - Compute Di, Ei
		capDi := signer.curve.ScalarBaseMult(di)
		capEi := signer.curve.ScalarBaseMult(ei)
		signingCommitment := &SigningCommitment{
			capDi: capDi,
			capEi: capEi,
		}
		signingCommitments = append(signingCommitments, signingCommitment)
	}

	// Store dis, eis
	signer.smallDs = dis
	signer.smallEs = eis
	return signingCommitments, nil
}

// removeFirstNonce removes the first nonce from a nonce slice.
func removeFirstNonce(slice []curves.Scalar, i int) []curves.Scalar {
	copy(slice[i:], slice[i+1:])
	return slice[:len(slice)-1]
}

// Sign is the actual signing round method for each signer to sign a message. This generates a signature share.
func (signer *Signer) Sign(msg []byte, signingCommitments map[uint32]*SigningCommitment) (*SignatureShare, error) {
	// Make sure necessary items of signer are not empty
	if signer == nil || signer.curve == nil {
		return nil, internal.ErrNilArguments
	}

	// Make sure those private d is not empty and not zero
	if signer.smallDs == nil || len(signer.smallDs) == 0 {
		return nil, fmt.Errorf("empty d nonce array")
	}

	// Make sure those private e is not empty and not zero
	if signer.smallEs == nil || len(signer.smallEs) == 0 {
		return nil, fmt.Errorf("empty e nonce array")
	}

	// Make sure msg is not empty
	if len(msg) == 0 {
		return nil, internal.ErrNilArguments
	}

	// Check length of round2Input
	if uint32(len(signingCommitments)) != signer.threshold {
		return nil, fmt.Errorf("invalid length of round2Input")
	}

	// Check cosigners are contained in signingCommitments Ids
	for _, id := range signer.cosigners {
		_, containsId := signingCommitments[id]
		if !containsId {
			return nil, fmt.Errorf("invalid signingCommitments doesn't contain id %d", id)
		}
	}

	// Check Dj, Ej on the curve and store commitments
	for id, input := range signingCommitments {
		if input == nil || input.capDi == nil || input.capEi == nil {
			return nil, fmt.Errorf("round2Input is nil from participant with id %d", id)
		}
		if !input.capDi.IsOnCurve() || input.capDi.IsIdentity() {
			return nil, fmt.Errorf("commitment Di is not on the curve with id %d", id)
		}
		if !input.capEi.IsOnCurve() || input.capEi.IsIdentity() {
			return nil, fmt.Errorf("commitment Ei is not on the curve with id %d", id)
		}
	}

	// Check Dj and Ej are valid with stored di, ei
	if len(signer.smallDs) == 0 || len(signer.smallEs) == 0 {
		return nil, fmt.Errorf("no nonce to use")
	}

	mySigningCommitment := signingCommitments[signer.id]
	di := signer.smallDs[0]
	ei := signer.smallEs[0]
	if !signer.curve.ScalarBaseMult(di).Equal(mySigningCommitment.capDi) {
		return nil, fmt.Errorf("commitment opening Di is wrong")
	}
	if !signer.curve.ScalarBaseMult(ei).Equal(mySigningCommitment.capEi) {
		return nil, fmt.Errorf("commitment opening Ei is wrong")
	}

	// Step 1 - Compute ri, R, Ri
	capR := signer.curve.NewIdentityPoint()
	var ri curves.Scalar
	capRis := make(map[uint32]curves.Point, signer.threshold)
	for id, data := range signingCommitments {
		// construct the blob (j, m, {Dj, Ej})
		blob := concatHashArray(id, msg, signingCommitments, signer.cosigners)

		// Compute rj = H(j, m, {Dj, Ej}_{j in [1...t]})
		rj := signer.curve.Scalar.Hash(blob)
		if signer.id == id {
			ri = rj
		}

		// Rj = Dj + rj * Ej
		rjEj := data.capEi.Mul(rj)
		capRj := rjEj.Add(data.capDi)
		// assign Rj
		capRis[id] = capRj

		// R = R+Rj
		capR = capR.Add(capRj)
	}

	// c = H(m, R)
	c, err := signer.challengeDeriver(msg, signer.verificationKey, capR)
	if err != nil {
		return nil, err
	}

	// Store c, R, Rjs
	signer.c = c
	signer.capRis = capRis
	signer.capR = capR

	// zi = di + ei*ri + Li*ski*c
	Li := signer.lCoeffs[signer.id]
	Liski := Li.Mul(signer.skShare)
	Liskic := Liski.Mul(c)
	eiri := ei.Mul(ri)

	// Compute zi = di+ei*ri + Li*ski*c
	zi := Liskic.Add(eiri)
	zi = zi.Add(di)

	// store message
	signer.msg = msg

	// remove the first pair of nonces since they are one-time use.
	signer.smallDs = removeFirstNonce(signer.smallDs, 0)
	signer.smallEs = removeFirstNonce(signer.smallEs, 0)

	return &SignatureShare{
		zi,
	}, nil
}

// concatHashArray puts id, msg and (Dj,Ej), j=1...t into a byte array.
func concatHashArray(id uint32, msg []byte, round2Input map[uint32]*SigningCommitment, cosigners []uint32) []byte {
	var blob []byte //nolint:prealloc // readability is lower if we specify the size to be 1 + len(msg) + (len(cosigners) * 3)
	// Append identity id
	blob = append(blob, byte(id))

	// Append message msg
	blob = append(blob, msg...)

	// Append (Dj, Ej) for all j in [1...t]
	for i := 0; i < len(cosigners); i++ {
		id := cosigners[i]
		bytesDi := round2Input[id].capDi.ToAffineCompressed()
		bytesEi := round2Input[id].capEi.ToAffineCompressed()

		// Following the spec, we should add each party's identity.
		blob = append(blob, byte(id))
		blob = append(blob, bytesDi...)
		blob = append(blob, bytesEi...)
	}
	return blob
}
